use pyo3::prelude::*;
mod graph;
mod operations;
mod engine;

use engine::GeneticOptimizer;

#[pymodule]
fn rust_graph_refiner(m: &Bound<'_, PyModule>) -> PyResult<()> {
    // Add the main optimizer class to the module
    m.add_class::<GraphRefiner>()?;
    Ok(())
}

/// The main interface called from Python.
/// It holds the state of the optimization process.
#[pyclass]
struct GraphRefiner {
    optimizer: GeneticOptimizer,
}

#[pymethods]
impl GraphRefiner {
    /// Create a new graph refiner using the commandâ€‘string GA.  `population_size`
    /// controls how many genomes are maintained and `gene_length` sets the
    /// number of encoded commands in each genome.
    #[new]
    fn new(population_size: usize, gene_length: usize) -> Self {
        GraphRefiner {
            optimizer: GeneticOptimizer::new(population_size, gene_length),
        }
    }

    /// Load the initial graph generated by the WGAN.  Accepts a number of
    /// nodes and a list of undirected edges.  Initializes the population
    /// of genomes based on this base graph.
    fn load_initial_graph(&mut self, num_nodes: usize, edge_index: Vec<(usize, usize)>) {
        self.optimizer.initialize_population(num_nodes, edge_index);
    }

    /// Run the genetic algorithm for a set number of generations.  Returns
    /// the best fitness score achieved in this run.  The current
    /// implementation does not compute a real fitness and always returns
    /// `0.0` as a placeholder.
    fn evolve(&mut self, generations: usize) -> f64 {
        self.optimizer.evolve(generations)
    }

    /// Retrieve the refined edges of the best candidate found so far.
    fn get_best_graph(&self) -> Vec<(usize, usize)> {
        self.optimizer.get_best_edges()
    }
}

pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}