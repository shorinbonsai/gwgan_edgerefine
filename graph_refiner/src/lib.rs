use pyo3::prelude::*;
mod graph;
mod operations;
mod engine;

use engine::GeneticOptimizer;

/// This module is implemented in Rust.
#[pymodule]
fn rust_graph_refiner(_py: Python, m: &PyModule) -> PyResult<()> {
    // Add the main optimizer class to the module
    m.add_class::<GraphRefiner>()?;
    Ok(())
}

/// The main interface called from Python.
/// It holds the state of the optimization process.
#[pyclass]
struct GraphRefiner {
    optimizer: GeneticOptimizer,
}

#[pymethods]
impl GraphRefiner {
    #[new]
    fn new(population_size: usize, mutation_rate: f64) -> Self {
        GraphRefiner {
            optimizer: GeneticOptimizer::new(population_size, mutation_rate),
        }
    }

    /// Load the initial graph generated by the WGAN.
    /// Accepts an edge_index (list of list of ints) or adjacency matrix.
    fn load_initial_graph(&mut self, num_nodes: usize, edge_index: Vec<(usize, usize)>) {
        self.optimizer.initialize_population(num_nodes, edge_index);
    }

    /// Run the Genetic Algorithm for a set number of generations.
    /// Returns the best fitness score achieved in this run.
    fn evolve(&mut self, generations: usize) -> f64 {
        self.optimizer.evolve(generations)
    }

    /// Retrieve the refined edges of the best candidate found so far.
    fn get_best_graph(&self) -> Vec<(usize, usize)> {
        self.optimizer.get_best_edges()
    }
}

pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
