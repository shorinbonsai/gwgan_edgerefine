use pyo3::prelude::*;
mod graph;
mod operations;
pub mod engine;
mod stats;

use std::io::{Write, BufWriter};

use engine::GeneticOptimizer;

#[pymodule]
mod graph_refiner {
    use super::*;

    // Re-export the class; PyO3 automatically adds it to the module
    #[pymodule_export]
    use super::GraphRefiner;
}

/// The main interface called from Python.
/// It holds the state of the optimization process.
#[pyclass]
pub struct GraphRefiner {
    optimizer: GeneticOptimizer,
}

#[pymethods]
impl GraphRefiner {
    /// Create a new graph refiner using the commandâ€‘string GA.  `population_size`
    /// controls how many genomes are maintained and `gene_length` sets the
    /// number of encoded commands in each genome.
    #[new]
    pub fn new(population_size: usize, gene_length: usize) -> Self {
        GraphRefiner {
            optimizer: GeneticOptimizer::new(population_size, gene_length),
        }
    }

    /// Load the initial graph generated by the WGAN.  Accepts a number of
    /// nodes and a list of undirected edges.  Initializes the population
    /// of genomes based on this base graph.
    pub fn load_initial_graph(&mut self, num_nodes: usize, edge_index: Vec<(usize, usize)>, seed: u64) {
        self.optimizer.initialize_population(num_nodes, edge_index, seed);
    }

    /// Sets the probability weights for the 9 graph operations.
    /// Order: [Toggle, LocalToggle, Hop, Add, Delete, Swap, LocalAdd, LocalDelete, Null]
    pub fn set_operation_weights(&mut self, weights: Vec<f64>) {
        self.optimizer.set_op_weights(weights);
    }

    pub fn set_target_statistics(
        &mut self,
        target_degrees: Vec<Vec<f64>>, degree_mean: Vec<f64>, degree_std: Vec<f64>,
        target_clustering: Vec<Vec<f64>>, clust_mean: Vec<f64>, clust_std: Vec<f64>,
        target_spectral: Vec<Vec<f64>>, spec_mean: Vec<f64>, spec_std: Vec<f64>,
        weights: (f64, f64, f64),
        gammas: (f64, f64, f64) // Added gammas argument
    ) {
        self.optimizer.set_targets(
            target_degrees, degree_mean, degree_std,
            target_clustering, clust_mean, clust_std,
            target_spectral, spec_mean, spec_std,
            weights, gammas
        );
    }

    /// Run the genetic algorithm for a set number of generations.  Returns
    /// the best fitness score achieved in this run.  The current
    /// implementation does not compute a real fitness and always returns
    /// `0.0` as a placeholder.
    pub fn evolve(&mut self, generations: usize, seed: u64) -> f64 {
        self.optimizer.evolve(generations, seed)
    }

    /// Retrieve the refined edges of the best candidate found so far.
    pub fn get_best_graph(&self) -> Vec<(usize, usize)> {
        self.optimizer.get_best_edges()
    }

    pub fn save_logs(&self, filename: &str) -> PyResult<()> {
        // The ? operator automatically converts std::io::Error to a Python OSError
        self.optimizer.save_logs(filename)?;
        Ok(())
    }

    pub fn save_results(&self, filename: &str) -> PyResult<()> {
        self.optimizer.save_results(filename)?;
        Ok(())
    }

}

pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}