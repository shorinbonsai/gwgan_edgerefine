# **GWGAN Edge Refinement**

This research project integrates a Generative Adversarial Network (GAN) with an Evolutionary Algorithm (EA) to refine graph edge structures. The system uses a Python-based GAN for initial generation and a high-performance Rust extension for evolutionary refinement.

# **Rust Graph Refiner**

**graph\_refiner** is a high-performance Python extension written in Rust. It implements a Genetic Algorithm (GA) to refine and optimize the edge structures of graphs generated by WGAN models.

This library is designed to be called directly from Python but executes its evolutionary logic in parallel using Rust's rayon library, offering significant speedups over pure Python implementations.

## **Features**

* **THADS-N Representation:** Implements the specific graph mutation operators (Toggle, Hop, Swap, Local Add/Delete, etc.) defined in *Representation for Evolution of Epidemic Models* (Dube et al.).  
* **Parallel Execution:** Uses rayon to evaluate and mutate the entire population of graphs simultaneously across all CPU cores.  
* **Python Integration:** Built with pyo3 and maturin for zero-overhead data transfer between PyTorch/NetworkX and Rust.


## **Installation**

### **(Using Pre-built Wheels)**

If you have been provided a .whl file, you do **not** need Rust installed. Simply run:

pip install rust\_graph\_refiner-0.1.0-cp38-abi3-manylinux\_2\_17\_x86\_64.whl

*(Note: Replace the filename with the specific version).*

### **(Building from Source)**

To modify the Rust code, you need [Rust installed](https://rustup.rs/) and maturin.

1. Install Maturin:  
   pip install maturin

2. Build and install into your current Python environment:  
   \# Run this from inside the rust\_graph\_refiner directory  
   maturin develop \--release

   *The \--release flag is critical for Genetic Algorithm performance.*


## **Usage**

Here is an example of how to use the library within a Python script to refine a graph generated by PyTorch Geometric.

```python
import graph_refiner
import torch

# 1. Configuration
POPULATION_SIZE = 500
GENE_LENGTH = 20  # Number of mutations (add/del/swap) to apply per candidate
GENERATIONS = 50

# 2. Initialize the Rust optimizer
refiner = graph_refiner.GraphRefiner(POPULATION_SIZE, GENE_LENGTH)

# 3. Prepare data from your PyTorch Geometric Data object
# Assuming 'fake_data' is the output from your Generator
num_nodes = fake_data.num_nodes
edge_index_tensor = fake_data.edge_index  # Shape [2, NumEdges]

# Convert tensor to a list of (u, v) tuples for Rust
edges_list = []
if edge_index_tensor.numel() > 0:
    edge_index_np = edge_index_tensor.cpu().numpy().T
    # Ensure tuples are standard Python ints
    edges_list = [(int(u), int(v)) for u, v in edge_index_np]

# 4. Load the graph into Rust
refiner.load_initial_graph(num_nodes, edges_list)

# 5. Run the evolution
# This releases the GIL and uses all CPU cores via Rayon
best_fitness = refiner.evolve(GENERATIONS)
print(f"Evolution complete. Best Fitness: {best_fitness}")

# 6. Retrieve the optimized edges
refined_edges_list = refiner.get_best_graph()

# 7. Convert back to PyTorch format
if refined_edges_list:
    refined_edge_index = torch.tensor(refined_edges_list, dtype=torch.long).t()
    print(f"Refined graph has {refined_edge_index.size(1)} edges.")
else:
    refined_edge_index = torch.empty((2, 0), dtype=torch.long)
```


## **Reference**

Based on the operators defined in:

Dube, M., Houghten, S., & Ashlock, D. (2019). "Representation for Evolution of Epidemic Models". IEEE Congress on Evolutionary Computation.